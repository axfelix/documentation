---
id: durable-execution
title: Go SDK developer's guide - Durable Execution
sidebar_label: Durable Execution
sidebar_position: 3
description: The Durable Execution section of the Temporal Developer's guide covers advanced beginner concepts for working with Temporal, including testing your code, reviewing workflow event history, adding timers, and understanding determinism. Developing for durable execution is a core aspect of Temporal.
slug: /dev-guide/go/durable-execution
toc_max_heading_level: 4
keywords:
- determinism
- developer-guide-doc-type
- durable execution
- event history
- go sdk
- how-to-doc-type
- introduction-doc-type
- replay
- testing
- workflow execution
tags:
- determinism
- developer-guide-doc-type
- durable-execution
- event-history
- go-sdk
- how-to-doc-type
- introduction-doc-type
- replay
- testing
- workflow-execution
---

<!-- THIS FILE IS GENERATED. DO NOT EDIT THIS FILE DIRECTLY -->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Durable Execution section of the Temporal Developer's guide covers advanced beginner concepts for working with Temporal, including testing your code, reviewing workflow event history, adding timers, and understanding determinism. Developing for durable execution is a core aspect of Temporal, and builds on the concepts introduced in our [Foundations](https://docs.temporal.io/dev-guide/go/foundations) guide.

For more information about Durable Execution, refer to our [blog about Building Reliable Distributed Systems in Node.js](https://temporal.io/blog/building-reliable-distributed-systems-in-node) and our [Temporal 102 course](https://learn.temporal.io/courses/temporal_102/).

In this section you can find the following:

<!-- - [How to retrieve Workflow Event History](/go/chapter-durable-execution/retrieve-event-history) -->

- [How to replay a Workflow Execution in Go](#workflowreplayer)
- [How to test Workflow Event History in Go](#testing-workflow-event-history)
- [Understand durability through Replays](#durability-through-replays)
- [Workflow Determinism](#workflow-determinism)

## How to replay a Workflow Execution in Go {#workflowreplayer}

Use the [worker.WorkflowReplayer](https://pkg.go.dev/go.temporal.io/sdk/worker#WorkflowReplayer) to replay an existing Workflow Execution from its Event History to replicate errors.

For example, the following code retrieves the Event History of a Workflow:

```go
import (
	"context"

	"go.temporal.io/api/enums/v1"
	"go.temporal.io/api/history/v1"
	"go.temporal.io/sdk/client"
)

func GetWorkflowHistory(ctx context.Context, client client.Client, id, runID string) (*history.History, error) {
	var hist history.History
	iter := client.GetWorkflowHistory(ctx, id, runID, false, enums.HISTORY_EVENT_FILTER_TYPE_ALL_EVENT)
	for iter.HasNext() {
		event, err := iter.Next()
		if err != nil {
			return nil, err
		}
		hist.Events = append(hist.Events, event)
	}
	return &hist, nil
}
```

This history can then be used to _replay_.
For example, the following code creates a `WorkflowReplayer` and register the `YourWorkflow` Workflow function.
Then it calls the `ReplayWorkflowHistory` to _replay_ the Event History and return an error code.

```go
import (
	"context"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
)

func ReplayWorkflow(ctx context.Context, client client.Client, id, runID string) error {
	hist, err := GetWorkflowHistory(ctx, client, id, runID)
	if err != nil {
		return err
	}
	replayer := worker.NewWorkflowReplayer()
	replayer.RegisterWorkflow(YourWorkflow)
	return replayer.ReplayWorkflowHistory(nil, hist)
}
```

The code above will cause the Worker to re-execute the Workflow's Workflow Function using the original Event History.
If a noticeably different code path was followed or some code caused a deadlock, it will be returned in the error code.
Replaying a Workflow Execution locally is a good way to see exactly what code path was taken for given input and events.

You can replay many Event Histories by registering all the needed Workflow implementation and then calling `ReplayWorkflowHistory` repeatedly.

## How to test Workflow Event History in Go {#testing-workflow-event-history}

<!-- DO NOT EDIT THIS FILE DIRECTLY.
THIS FILE IS GENERATED from https://github.com/temporalio/documentation-samples-go/blob/port_replay_test_dacx/yourapp/replay/your_workflow_definition_replay_dacx_test.go. -->

TestReplayWorkflowHistoryFromFile tests the code against the existing Worklow History saved to the JSON file.
This Replay test is the recommended way to make sure changing workflow code is backward compatible without non-deterministic errors.
"your_workflow_history.json" can be downloaded from the Web UI or the Temporal CLI:

    `temporal workflow show --workflow-id your-workflow-id --output json  > your_workflow_history.json`

:::copycode Sample application code

The following code sample comes from a working and tested sample application.
The code sample might be abridged within the guide to highlight key aspects.
Visit the source repository to [view the source code](https://github.com/temporalio/documentation-samples-go/blob/port_replay_test_dacx/yourapp/replay/your_workflow_definition_replay_dacx_test.go) in the context of the rest of the application code.

:::

```go
func TestReplayWorkflowHistoryFromFile(t *testing.T) {
	replayer := worker.NewWorkflowReplayer()

	replayer.RegisterWorkflow(YourWorkflowDefinition)

	err := replayer.ReplayWorkflowHistoryFromJSONFile(nil, "your_workflow_history.json")
	require.NoError(t, err)
}
```

## Understanding durability through Replays {#durability-through-replays}

If a regular function in Go crashes during execution, all of its state is lost. It can't be resumed, only restarted. From the developer's perspective, a Temporal Workflow resumes its execution at the point where the crash occurred, with all previous state intact, and continues on from there. You might wonder how it's able to achieve this, since there's no obvious checkpointing or state management in the code.

[History Replay](https://docs.temporal.io/dev-guide/go/testing#replay), sometimes also called Workflow Replay, is the mechanism that Temporal uses to reconstruct the state of a Workflow Execution.

Temporal Workflow Execution works like so:

- The client application starts a Workflow Execution by calling the Temporal client SDK API like client.start_workflow() and passing the Workflow function to execute.
- This sends a command to the Temporal server to start the Workflow Execution. The server persists the Workflow state and sends back the WorkflowExecution handle.
- The client passes this WorkflowExecution to a Worker process to run it.
- The Worker loads the Workflow function definition and starts executing it step-by-step like a normal function.
- When the code hits an await on an async activity or signal, the Worker generates a Task based on that and returns execution back to the event loop.
- The Worker keeps polling the Temporal server for Tasks for that WorkflowExecution. When a Task is available, it executes the corresponding Activity function or Signal callback.
- Once the awaited Activity or Signal completes, the Workflow code resumes from where it left off and continues execution.
- This sequence continues until the Workflow function completes or hits a wait condition. The Worker persists the current state with Temporal server.
- Later, when a waited on condition is completed or a Task is available, the server notifies the Worker which loads the state and resumes Workflow execution.
- The Workflow code keeps running like this through different Workers until final completion. The Temporal server orchestrates persistence and hand-offs.

Certain Events in the history are a direct result of a particular Command issued by a Worker. For example, the `ScheduleActivityTask` Command results in an `ActivityTaskScheduled` Event, while the `StartTimer` Command results in a `TimerStarted` Event.

During Workflow Replay, the Worker uses this information to recover the state of the previous execution.

For example, if the `ScheduleActivityTask` Command has a corresponding `ActivityTaskScheduled` Event in the history, and this is followed by `ActivityTaskStarted` and `ActivityTaskCompleted` Events for that same Activity Type, it's clear that this Activity already ran successfully. In this case, the Worker does not issue the Command to the cluster requesting a new execution of the Activity. Instead, it assigns the result of the previous Activity Execution, which is stored in the Event History.

To further understand this concept, you can watch [How Temporal Provides Durable Execution](https://www.youtube.com/embed/5eNqspaNoxo?rel=0&iv_load_policy=3&modestbranding=1&showse) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course.

The example application from this section generates eight different types of events:

- `WorkflowExecutionStarted`
- `WorkflowTaskScheduled`
- `WorkflowTaskStarted`
- `WorkflowTaskCompleted`
- `ActivityTaskScheduled`
- `ActivityTaskStarted`
- `ActivityTaskCompleted`
- `WorkflowExecutionCompleted`

For example, a `ScheduleActivityTask` command in SDK code generates an `ActivityTaskScheduled` Event server-side, and a `CompleteWorkflowExecution` command in the SDK generates a `WorkflowExecutionCompleted` Event. The Temporal API currently defines more than three dozen different types of Events.

Each logged Event defines one or more attributes used to store information specific to that Event, such as the error associated with a failed Activity or the duration of a Timer. Every Event has at least three attributes in common. The first is the Event ID, which uniquely identifies this Event within the History and also its position within the history. The second is the Event time, which is a timestamp representing when the Event occurred. The third is the Event Type, which specifies what kind of Event it is.

Events may also contain additional attributes that vary based on the Event Type. For example, the WorkflowExecutionStarted Event contains the Workflow Type and the data provided as input to at the start of execution. The `WorkflowExecutionCompleted` Event contains the result of that execution, while failed Workflows will end with a `WorkflowExecutionFailed` Event that contains the error returned by that execution.

For a complete list of events that can be produced by the Temporal Cluster, refer to the [Event Reference](https://docs.temporal.io/references/events). You can also watch [How Workflow Code Maps to Commands](https://www.youtube.com/embed/sjrZJEfe7NE?rel=0&iv_load_policy=3&modestbranding=1&showsearch=0&showinfo=0&wmode=transparent) and [How Commands Map to Events](https://www.youtube.com/embed/EcGcu-Q9sRw?rel=0&iv_load_policy=3&modestbranding=1&showsearch=0&showinfo=0&wmode=transparent) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course, or refer to refer to [Let's Visualize a Workflow](https://temporal.io/blog/lets-visualize-a-workflow) on the Temporal blog.

## Workflow Determinism {#workflow-determinism}

A critical aspect of developing Workflow Definitions is ensuring they exhibit certain deterministic traits – that is, making sure that the same Commands are emitted in the same sequence, whenever a corresponding Workflow Function Execution (instance of the Function Definition) is re-executed.

A mismatch between the Commands that the Worker expected, based on the Event History, and those created, based on actually executing the code, results in a non-deterministic error. This error means that the Worker cannot accurately restore the state of the Workflow Execution. Since the Workflow Definition produced a different sequence of Commands during replay than it did prior to the crash, the Worker is unable to restore the previous state, so the use of random numbers in the Workflow code has resulted in a non-deterministic error.

You can also watch [Deployment Leads to Non-Deterministic Error](https://www.youtube.com/embed/8DkMdaUu0vQ?rel=0&iv_load_policy=3&modestbranding=1&showse) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course, or refer to the [Deterministic constraints](https://docs.temporal.io/workflows#deterministic-constraints) documentation.

### Examples of Changes That May Lead to Non-Deterministic Errors

- Adding or removing an Activity
- Switching the Activity Type used in a call to `ExecuteActivity`
- Adding or removing a Timer
- Altering the execution order of Activities or Timers relative to one another

### Examples of Changes That Do Not Lead to Non-Deterministic Errors

- Modifying statements in a Workflow Definition, such as logging statements, that do not affect the Commands generated during Workflow Execution
- Changing attributes in a `ActivityOptions` or `RetryPolicy`
- Modifying code inside of an Activity Definition

### Common Sources of Non-Determinism

- Using Random numbers
- Accessing / Mutating External Systems or State (do this in Activities, not Workflows)
- Relying on System Time (use [Workflow.now()](https://pkg.go.dev/go.temporal.io/sdk/workflow#Now) instead)
- Working Directly with Threads or Goroutines (use [Workflow.go()](https://pkg.go.dev/go.temporal.io/sdk/workflow#Go) instead)
- Iterating over Data Structures with Unknown Ordering
- Storing or Evaluating the [Run ID](https://docs.temporal.io/workflows#run-id)

### Demonstrating a Non-Deterministic Error

To produce a Non-Deterministic Error following the example in this section, you can add a random number generator and a `time.Sleep` call — two things you should never do in a Temporal Workflow.

Add `"math/rand"` to the list of imported packages at the start of `your_workflow_definition_dacx.go`, and add `time.Sleep(time.Duration(rand.Intn(10)) * time.Second)` to line 68, just after `ctx = workflow.WithActivityOptions(ctx, activityOptions)`:

```go
import (
	"time"
	"math/rand"
	"go.temporal.io/sdk/workflow"
)

...

	ctx = workflow.WithActivityOptions(ctx, activityOptions)
	time.Sleep(time.Duration(rand.Intn(10)) * time.Second)  
	activityParam := YourActivityParam{
		ActivityParamX: param.WorkflowParamX,
		ActivityParamY: param.WorkflowParamY,
	}
```

Save the file, then re-run both the Worker Process and the HTTP server as before:

```shell
go run worker/main_dacx.go
go run gateway/main_dacx.go
```

Once both the Worker process and the HTTP server are running, access `http://localhost:8091/start` using either your browser or `curl`. It will not return any output to the browser or cURL command. Reload the page or re-run cURL at least twice to ensure that the Temporal Cluster catches the non-deterministic behavior that you've added.

Next, you can reopen the Temporal [Web UI](http://localhost:8233/) to find a problem with your Workflow:

<div class="tdiw"><div class="tditw"><p class="tdit">Web UI view of a non-determinism error</p></div><div class="tdiiw"><img class="img_ev3q" src="/img/deterministic-failure.png" alt="Web UI view of a non-determinism error" height="335" width="943" /></div></div>

Use the `temporal workflow show` command again to retrieve the Workflow Event History:

```shell
temporal workflow show --workflow-id your-workflow-id --output json  > your_workflow_history.json
```

This Workflow output contains a `WorkflowTaskFailed` event, which will fail the `TestReplayWorkflowHistoryFromFile()` test:

```output
{
  "eventId": "4",
  "eventTime": "2023-10-16T22:02:33.225671800Z",
  "eventType": "WorkflowTaskFailed",
  "taskId": "1048672",
  "workflowTaskFailedEventAttributes": {
    "scheduledEventId": "2",
    "startedEventId": "3",
    "cause": "WorkflowWorkerUnhandledFailure",
```

Testing for Non-Determinism errors can help improve your Temporal Workflows. You can also watch [Using Workflow Reset to Recover from a Bad Deployment](https://www.youtube.com/embed/wKnGbukEppI?rel=0&iv_load_policy=3&modestbranding=1&showsearch=0&showinfo=0&wmode=transparent) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course.

### Wrapped Language Primitives

The Temporal Go SDK provides wrappers around some Go language primitives — `time.Sleep()` and `time.Now()` — so you can safely use them within Temporal Workflows.

Use [workflow.Sleep()](https://pkg.go.dev/go.temporal.io/sdk/workflow#Sleep) to pause a Workflow. Unlike `time.Sleep()`, `workflow.Sleep()` requires you to pass the Workflow `Context` as an additional argument. It also allows you to programmatically cancel a pending sleep, and to automatically advance past a sleep duration when testing.

Use [workflow.Now()](https://pkg.go.dev/go.temporal.io/sdk/workflow#Now) to returns the current time when the workflow task is started or replayed. Workflows must use this Now() to get the wall clock time.
