---
id: durability-through-replays
title: Understanding durability through Replays
description: 
sidebar_label: Durability through Replays
tags:
  - go sdk
  - developer-guide-doc-type
  - event history
  - 
  -
---

If a regular function in Go crashes during execution, all of its state is lost. It can't be resumed, only restarted. From the developer's perspective, a Temporal Workflow resumes its execution at the point where the crash occurred, with all previous state intact, and continues on from there. Since you've already seen and run several Workflows, you might wonder how it's able to achieve this, since there's no obvious checkpointing or state management in the code.

History Replay, sometimes also called Workflow Replay, is the mechanism that Temporal uses to reconstruct the state of a Workflow Execution.


- Workflow Code Execution:
• The client application starts a Workflow Execution by calling the Temporal client SDK API like client.start_workflow() and passing the Workflow function to execute.
• This sends a command to the Temporal server to start the Workflow Execution. The server persists the Workflow state and sends back the WorkflowExecution handle. 
• The client passes this WorkflowExecution to a Worker process to run it. 
• The Worker loads the Workflow function definition and starts executing it step-by-step like a normal function. 
• When the code hits an await on an async activity or signal, the Worker generates a Task based on that and returns execution back to the event loop.
• The Worker keeps polling the Temporal server for Tasks for that WorkflowExecution. When a Task is available, it executes the corresponding Activity function or Signal callback.
• Once the awaited Activity or Signal completes, the Workflow code resumes from where it left off and continues execution.
• This sequence continues until the Workflow function completes or hits a wait condition. The Worker persists the current state with Temporal server.
• Later, when a waited on condition is completed or a Task is available, the server notifies the Worker which loads the state and resumes Workflow execution.
• The Workflow code keeps running like this through different Workers until final completion. The Temporal server orchestrates persistence and hand-offs.
So in summary, the client starts Workflows, Workers run Workflow and Activity code, and Temporal server persists state and coordinates everything.



TODO:
- Provide set of APIs that are used in this Workflow Execution.
- Start with ExecuteActivity and StartTimer
- Link back to complete set of Events/Commands (autogenerated?).


• ScheduleActivityTask Command -> ActivityTaskScheduled Event
• RequestCancelActivityTask Command -> ActivityTaskCancelRequested Event 
• StartTimer Command -> TimerStarted Event
• CompleteWorkflowExecution Command -> WorkflowExecutionCompleted Event
• FailWorkflowExecution Command -> WorkflowExecutionFailed Event
• CancelTimer Command -> TimerCanceled Event 
• CancelWorkflowExecution Command -> WorkflowExecutionCancelRequested Event
• RequestCancelExternalWorkflowExecution Command -> RequestCancelExternalWorkflowExecutionInitiated Event
• SignalExternalWorkflowExecution Command -> SignalExternalWorkflowExecutionInitiated Event
• UpsertWorkflowSearchAttributes Command -> WorkflowExecutionSignaled Event

You can also watch [How Commands Map to Events](https://www.youtube.com/embed/EcGcu-Q9sRw?rel=0&iv_load_policy=3&modestbranding=1&showsearch=0&showinfo=0&wmode=transparent) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course.


You can also watch [How Temporal Provides Durable Execution](https://www.youtube.com/embed/5eNqspaNoxo?rel=0&iv_load_policy=3&modestbranding=1&showse) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course.

You can also watch [How Workflow Code Maps to Commands](https://www.youtube.com/embed/sjrZJEfe7NE?rel=0&iv_load_policy=3&modestbranding=1&showsearch=0&showinfo=0&wmode=transparent) from our [Temporal 102](https://learn.temporal.io/courses/temporal_102/go) course.


You can also refer to [Let's Visualize a Workflow](https://temporal.io/blog/lets-visualize-a-workflow) on the Temporal blog.


You've already seen that a history can contain many different types of Events, such as `WorkflowExecutionStarted` or `ActivityTaskScheduled`. The Temporal API currently defines more than three dozen different types of Events. 

Each of these defines one or more attributes used to store information  specific to that Event, such as the error associated with a failed  Activity or the duration of a Timer. Every Event has at least three  attributes in common. The first is the Event ID, which uniquely  identifies this Event within the History and also its position within  the history. The second is the Event time, which is a timestamp  representing when the Event occurred. The third is the Event Type,  which specifies what kind of Event it is.

Events may also contain additional attributes that vary based on the Event Type. For example, the WorkflowExecutionStarted Event contains the Workflow Type and the data provided as input to at the start of execution. The `WorkflowExecutionCompleted` Event contains the result of that execution, while failed Workflows will end with a `WorkflowExecutionFailed` Event that contains the error returned by that execution. 

Events related to Activity execution follow a similar pattern. For  example, the `ActivityTaskScheduled` Event contains the Activity Type  and input parameters, while the `ActivityTaskCompleted` Event contains the result of that execution.

As you will see during the upcoming demonstration, Events related to Task scheduling will contain information about execution Timeouts and Retry Policies.
